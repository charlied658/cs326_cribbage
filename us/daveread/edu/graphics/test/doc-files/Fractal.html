<html>
<head><title>Fractal Source Code</title></head>
<body>
<h1>Fractal</h1><h2>Screenshot</h2><img src="Fractal.png" alt="Screenshot" style="border:1px solid #000000"/>
<br clear="all"/>
<hr>
<h2>Source Code</h2>
<pre>
package us.daveread.edu.graphics.test;

import java.awt.Color;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.text.DecimalFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;

import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.KeyStroke;

import org.apache.log4j.Logger;

import us.daveread.edu.graphics.shape.impl.Pixel;
import us.daveread.edu.graphics.surface.DrawingSurface;
import us.daveread.edu.graphics.surface.ImageType;
import us.daveread.edu.graphics.surface.MainFrame;
import us.daveread.edu.graphics.surface.WindowMode;

/**
 * Abstract class to support plotting portions of fractals.
 * &lt;p&gt;
 * Here is a link to the &lt;a href=&quot;doc-files/Fractal.html&quot;&gt;Source Code&lt;/a&gt;.
 * &lt;/p&gt;
 * @author readda
 */
public abstract class Fractal extends DrawingSurface implements Runnable {

  /**
   * Serial version id
   */
  private static final long serialVersionUID = 1L;

  /**
   * Logger
   */
  private static final Logger LOG = Logger.getLogger(Fractal.class);

  /**
   * The limit value for determining that the calculation is clearly diverging
   */
  protected static final int LIMIT = 4;

  /**
   * The default number of rows in the display
   */
  // private static final int ROWS = 700;
  // private static final int ROWS = 960;
  private static final int ROWS = 1080;

  /**
   * The default number of columns in the display
   */
  // private static final int COLS = 700;
  private static final int COLS = 1920;

  /**
   * The color scheme to use
   */
  private FractalColorScheme colorScheme =
    FractalColorScheme.BLUE_GREENYELLOW_ORANGE;

  /**
   * Number of images to generate when auto zoom mode is used.
   */
  private static final int NUM_AUTO_ZOOM_IMAGES = 40;

  /**
   * The zoom factor. Numbers greater than 1 zoom in, while those less than 1
   * zooms out.
   */
  private static final double AUTO_ZOOM_FACTOR = 1 / 1.5;

  /**
   * The upper-left x value (real portion of the Complex number).
   */
  private double xStart;

  /**
   * The upper-left y value (imaginary portion of the Complex number).
   */
  private double yStart;

  /**
   * The distance to move in the x and y directions.
   */
  private double distance;

  /**
   * The maximum number of iterations to test each value for membership.
   */
  private int maxIterations;

  /**
   * The breakpoint for color interpolation.
   */
  private int colorInterpolateSwitchPoint;

  /**
   * Scaled unit in x direction
   */
  private double xIncrement;

  /**
   * Scaled unit in y direction
   */
  private double yIncrement;

  /**
   * Is auto zooming being used.
   * @see #runAutoZoom()
   */
  private boolean isAutoZoomingMode;

  /**
   * The count of auto zooming images created.
   * @see #runAutoZoom()
   */
  private int autoZoomingCount;

  /**
   * Formatting of the auto zooming counting value in the file name.
   */
  private DecimalFormat countFormat;

  /**
   * The set number for this group of zoomed images.
   */
  private String autoZoomingSetLabel;

  /**
   * For tracking the values seen for magnitude. Added to identify a better
   * way to do color interpolation.
   */
  HashMap&lt;Integer, Integer&gt; magnitudeCounts = new HashMap&lt;&gt;();

  /**
   * Create and setup the display
   * @param title
   *          The title for the frame
   * @param area
   *          The portion of the Mandelbrot area to initially be plotted
   */
  public Fractal(String title, FractalArea area) {
    MainFrame frame =
      new MainFrame(this, title, COLS, ROWS, WindowMode.FIXED_SIZE, false);
    frame.setJMenuBar(createMenuBar());

    xStart = area.xStart();
    yStart = area.yStart();
    distance = area.distance();
    maxIterations = area.maxIterations();
    colorInterpolateSwitchPoint = area.colorInterpolateSwitchPoint();

    countFormat = new DecimalFormat(&quot;00&quot;);
  }

  /**
   * Setup a menu bar for the program
   * @return The configured JMenuBar instance
   */
  private JMenuBar createMenuBar() {
    JMenuBar mb = new JMenuBar();
    JMenu menu;
    JMenuItem menuItem;

    menu = new JMenu(&quot;File&quot;);
    menu.setMnemonic('F');

    menuItem = new JMenuItem(&quot;Save Image to File&quot;, KeyEvent.VK_S);
    menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,
      ActionEvent.ALT_MASK));
    menu.add(menuItem);

    menu.addSeparator();

    menuItem = new JMenuItem(&quot;Exit&quot;, KeyEvent.VK_X);
    menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X,
      ActionEvent.ALT_MASK));
    menu.add(menuItem);

    mb.add(menu);

    return mb;
  }

  /**
   * Plot a point on the display
   * Color blending based on
   * http://stackoverflow.com/questions/17544157/generate-n-colors-between-two-
   * colors
   * @param row
   *          The row of the point
   * @param col
   *          The column of the point
   * @param magnitude
   *          The magnitude (e.g. iteration count) reached for this point
   */
  protected void plotOld(int row, int col, int magnitude) {
    Color x;
    Color y;
    float red;
    float green;
    float blue;
    float blending;
    float inverseBlending;

    if (magnitude &lt; colorInterpolateSwitchPoint) {
      // x = Color.BLUE.darker();
      // y = Color.BLUE.brighter();
      x = colorScheme.getOutsideStart();
      y = colorScheme.getOutsideEnd();

      blending = (colorInterpolateSwitchPoint - magnitude)
        / (float) colorInterpolateSwitchPoint;
      // System.out.println(&quot;Max Iter:&quot; + MAX_ITERATIONS + &quot; magnitude:&quot;
      // + magnitude + &quot; blending:&quot; + blending);
    } else if (magnitude &lt; colorInterpolateSwitchPoint * 2) {
      int adjMag = magnitude - colorInterpolateSwitchPoint;
      // x = Color.BLUE.brighter();
      // y = Color.YELLOW.brighter();
      // y = Color.GREEN.darker();
      x = colorScheme.getBorderStart();
      y = colorScheme.getBorderEnd();

      blending = (colorInterpolateSwitchPoint - adjMag)
        / (float) colorInterpolateSwitchPoint;

    } else {
      int adjMag = magnitude - colorInterpolateSwitchPoint * 2;
      // x = Color.YELLOW.brighter();
      // y = Color.RED.darker();
      // x = Color.GREEN.darker();
      // y = Color.YELLOW.brighter();
      x = colorScheme.getMemberStart();
      y = colorScheme.getMemberEnd();

      blending =
        ((maxIterations
          - colorInterpolateSwitchPoint * 2) - adjMag)
          / (float) (maxIterations
            - colorInterpolateSwitchPoint * 2);
      // System.out
      // .println(&quot;Max Iter Adj:&quot; + (MAX_ITERATIONS - COLOR_SWITCH_VALUE)
      // + &quot; adj magnitude:&quot;
      // + adjMag + &quot; blending:&quot; + blending);

    }

    inverseBlending = 1 - blending;

    red = x.getRed() * blending + y.getRed() * inverseBlending;
    green = x.getGreen() * blending + y.getGreen() * inverseBlending;
    blue = x.getBlue() * blending + y.getBlue() * inverseBlending;

    red = (float) Math.floor(red);
    green = (float) Math.floor(green);
    blue = (float) Math.floor(blue);

    // System.out.println(&quot;Red:&quot; + red + &quot; Green:&quot; + green + &quot; Blue:&quot; + blue);

    // note that if i pass float values they have to be in the range of 0.0-1.0
    // and not in 0-255 like the ones i get returned by the getters.
    Color blended = new Color(red / 255, green / 255, blue / 255);
    add(new Pixel(new Point(col, row), blended));
  }

  /**
   * Plot a point on the display
   * Color blending based on
   * http://stackoverflow.com/questions/17544157/generate-n-colors-between-two-
   * colors
   * @param row
   *          The row of the point
   * @param col
   *          The column of the point
   * @param magnitude
   *          The magnitude (e.g. iteration count) reached for this point
   */
  protected void plot(int row, int col, int magnitude) {
    Color x;
    Color y;
    float red;
    float green;
    float blue;
    float blending;
    float inverseBlending;

    int onethird = maxIterations / 3;

    if (magnitude &lt; onethird) {
      // x = Color.green.darker();
      // y = Color.blue.darker();
      y = colorScheme.getOutsideStart();
      x = colorScheme.getOutsideEnd();
      blending = (float) magnitude / onethird;
    } else if (magnitude &lt; onethird * 2) {
      // x = Color.yellow.brighter();
      // y = Color.green.darker();
      y = colorScheme.getBorderStart();
      x = colorScheme.getBorderEnd();
      blending = (float) (magnitude - onethird) / onethird;
    } else {
      // x = Color.orange;
      // y = Color.yellow.brighter();
      y = colorScheme.getMemberStart();
      x = colorScheme.getMemberEnd();
      blending = (float) (magnitude - onethird * 2) / onethird;
    }

    blending = Math.min(1, blending);

    inverseBlending = 1 - blending;

    // Tracking magnitude counts to inform design of better color interpolation
    // approach
    if (LOG.isTraceEnabled()) {
      if (magnitudeCounts.get(magnitude) == null) {
        magnitudeCounts.put(magnitude, 1);
      } else {
        magnitudeCounts.put(magnitude, magnitudeCounts.get(magnitude) + 1);
      }
    }

    red = (float) ((x.getRed() / 256.0) * blending
      + (y.getRed() / 256.0) * inverseBlending);
    green = (float) ((x.getGreen() / 256.0) * blending
      + (y.getGreen() / 256.0) * inverseBlending);
    blue = (float) ((x.getBlue() / 256.0) * blending
      + (y.getBlue() / 256.0) * inverseBlending);

    Color interpolated = new Color(red, green, blue);
    add(new Pixel(new Point(col, row), interpolated));
  }

  /**
   * Shift the image vertically and/or horizontally.
   * @param percVert
   *          The percentage of shift vertically. Positive values shift up,
   *          negative shift down
   * @param percHoriz
   *          The percentage of shift horizontally. Positive values shift right,
   *          negative shift left
   */
  private void shiftImage(double percVert, double percHoriz) {
    double xNew = xStart + distance * percHoriz;
    double yNew = yStart + distance * percVert;

    addMessage(
      &quot;Shift:  horiz,vert:(&quot; + percHoriz + &quot;,&quot; + percVert + &quot;) From:(&quot;
        + xStart + &quot;,&quot; + yStart + &quot;) To:(&quot; + xNew + &quot;,&quot; + yNew + &quot;)&quot;);

    xStart = xNew;
    yStart = yNew;

    clearSurface();

    new Thread(this).start();
  }

  /**
   * Update the plot based on the mouse click
   * @param recenterOnly
   *          Whether to ask the user for a zoom factor
   * @param x
   *          The x pixel location of the click
   * @param y
   *          The y pixel location of the click
   */
  private void updatePlot(boolean recenterOnly, int x, int y) {
    double xScaledClick;
    double yScaledClick;

    xScaledClick = xStart + (xIncrement * x);
    yScaledClick = yStart + (yIncrement * y);

    addMessage(&quot;Click location:  Screen(&quot; + x + &quot;,&quot; + y + &quot;) Scaled(&quot;
      + xScaledClick + &quot;,&quot; + yScaledClick + &quot;)&quot;);

    if (!recenterOnly) {
      String factorTemp =
        getUserInput(&quot;Set Zoom Factor&quot;,
          &quot;Zoom factor? (e.g. 2=magnify 2X, .5=zoom out .5X)&quot;);
      if (factorTemp != null) {
        try {
          double factor = Double.parseDouble(factorTemp);
          if (factor != 0) {
            distance *= 1 / factor;
            xIncrement *= 1 / factor;
            yIncrement *= 1 / factor;
          } else {
            addMessage(&quot;Factor of 0 is not supported, magnification unchanged&quot;);
          }
        } catch (Throwable throwable) {
          addMessage(&quot;Input is not a number: &quot; + factorTemp);
        }
      }
    }

    addMessage(&quot;Updated values: distance=&quot; + distance + &quot; xIncrement:&quot;
      + xIncrement + &quot; yIncrement:&quot; + yIncrement);

    LOG
      .debug(&quot;Update plot with width:&quot; + getWidth() + &quot; height:&quot; + getHeight());

    xStart = xScaledClick - (xIncrement * (getWidth() / 2));
    yStart = yScaledClick - (yIncrement * (getHeight() / 2));

    clearSurface();

    new Thread(this).start();
  }

  /**
   * Plot a portion of the Mandelbrot set using the coordinates and distance
   * entered by the user.
   */
  private void pickLocation() {
    String input = getUserInput(&quot;Plotting Coordinate Entry&quot;,
      &quot;Enter upper left plot point in form: X, Y, distance&quot;);

    if (input != null) {
      try {

        String[] parsed = input.split(&quot;,&quot;);

        xStart = Double.parseDouble(parsed[0].trim());
        yStart = Double.parseDouble(parsed[1].trim());
        distance = Double.parseDouble(parsed[2].trim());

        clearSurface();

        new Thread(this).start();
      } catch (Throwable throwable) {
        showErrorMessage(&quot;Incorrect coordinate entry&quot;,
          &quot;Unable to process user entered coordinates: &quot; + input + &quot;\n\n&quot;
            + throwable.getClass() + &quot;:&quot; + throwable.getMessage() + &quot;\n\n&quot;
            + &quot;Format is X value, Y value, distance to plot\n\n&quot;
            + &quot;Example: -0.20765427330992853,-0.6652471979726117,0.011237311385459543\n\n&quot;);
      }
    }
  }

  /**
   * Get the starting location X-coordinate within the fractal for the plot.
   * @return The starting X-coordinate
   */
  protected double getxStart() {
    return xStart;
  }

  /**
   * Set the starting location X-coordinate within the fractal for the plot.
   * @param xStart
   *          The starting X-coordinate
   */
  protected void setxStart(double xStart) {
    this.xStart = xStart;
  }

  /**
   * Get the starting location Y-coordinate within the fractal for the plot.
   * @return The starting Y-coordinate
   */
  protected double getyStart() {
    return yStart;
  }

  /**
   * Set the starting location Y-coordinate within the fractal for the plot.
   * @param yStart
   *          The starting Y-coordinate
   */
  protected void setyStart(double yStart) {
    this.yStart = yStart;
  }

  /**
   * Get the starting distance (both dimensions) of the fractal to plot.
   * @return The distance to plot
   */
  protected double getDistance() {
    return distance;
  }

  /**
   * Set the starting distance (both dimensions) of the fractal to plot.
   * @param distance
   *          The distance to plot
   */
  protected void setDistance(double distance) {
    this.distance = distance;
  }

  /**
   * Get the maximum number of iterations to test before assuming membership in
   * the set.
   * @return The maximum iterations to test
   */
  protected int getMaxIterations() {
    return maxIterations;
  }

  /**
   * Set the maximum number of iterations to test before assuming membership in
   * the set.
   * @param maxIterations
   *          The maximum iterations to test
   */
  protected void setMaxIterations(int maxIterations) {
    this.maxIterations = maxIterations;
  }

  /**
   * Get the increment distance in the X-direction within the fractal for the
   * plot.
   * @return The X-direction increment
   */
  protected double getxIncrement() {
    return xIncrement;
  }

  /**
   * Set the increment distance in the X-direction within the fractal for the
   * plot.
   * @param xIncrement
   *          The X-direction increment
   */
  protected void setxIncrement(double xIncrement) {
    this.xIncrement = xIncrement;
  }

  /**
   * Get the increment distance in the Y-direction within the fractal for the
   * plot.
   * @return The Y-direction increment
   */
  protected double getyIncrement() {
    return yIncrement;
  }

  /**
   * Set the increment distance in the Y-direction within the fractal for the
   * plot.
   * @param yIncrement
   *          The Y-direction increment
   */
  protected void setyIncrement(double yIncrement) {
    this.yIncrement = yIncrement;
  }

  @Override
  public void handleMouseClick(boolean left, int x, int y) {
    addMessage(&quot;Mouse click: left?&quot; + left + &quot; at (&quot; + x + &quot;, &quot; + y + &quot;)&quot;);
    updatePlot(left, x, y);
  }

  /**
   * Plot the fractal
   */
  public abstract void plot();

  /**
   * Save the currently displayed image to a file. The user will be prompted for
   * the file name.
   */
  private void saveCurrentImage() {
    String fileName =
      getUserInput(&quot;Save Image to File&quot;,
        &quot;Please enter the filename for the saved image&quot;, &quot;fract_x&quot; + getxStart()
          + &quot;_y&quot; + getyStart() + &quot;_d&quot; + getDistance() + &quot;.png&quot;);

    saveCurrentImage(fileName);
  }

  /**
   * Save the currently displayed image to a file.
   * @param fileName
   *          The name, with optional path, of the file to write
   */
  private void saveCurrentImage(String fileName) {
    if (fileName != null &amp;&amp; fileName.trim().length() &gt; 0) {
      try {
        saveImage(fileName, ImageType.PNG);
      } catch (Throwable throwable) {
        showErrorMessage(&quot;Error Saving File&quot;,
          &quot;Unable to save image to: &quot; + fileName + &quot;\n\n&quot; + throwable.getClass()
            + &quot;: &quot; + throwable.getMessage());
      }
    }
  }

  private void startAutoZoom() {
    addMessage(&quot;startAutoZoom called at &quot; + new Date());

    autoZoomingCount = 0;
    isAutoZoomingMode = true;

    addMessage(&quot;screen dimensions: (&quot; + getWidth() + &quot;, &quot; + getHeight() + &quot;)&quot;);

    try {
      autoZoomingSetLabel =
        getUserInput(&quot;Set Label?&quot;, &quot;What is the set label?&quot;).trim();
      if (autoZoomingSetLabel == null || autoZoomingSetLabel.length() == 0) {
        autoZoomingSetLabel = &quot;UNLABELED&quot;;
      }
      runAutoZoom();
    } catch (Throwable t) {
      addMessage(&quot;Error: illegal set number, auto zoom canceled&quot;);
      LOG.error(&quot;Illegal set number entered by the user&quot;, t);
    }
  }

  private void runAutoZoom() {
    addMessage(&quot;runAutoZoom called at &quot; + new Date());

    String fileName =
      &quot;MBT&quot; + &quot;s&quot; + autoZoomingSetLabel + &quot;n&quot;
        + countFormat.format(autoZoomingCount) + &quot;x&quot; + getxStart() + &quot;y&quot;
        + getyStart() + &quot;d&quot; + getDistance();
    addMessage(&quot;Auto zoom: save current image: &quot; + fileName);
    saveCurrentImage(fileName);

    if (autoZoomingCount &lt; NUM_AUTO_ZOOM_IMAGES) {
      ++autoZoomingCount;

      // Auto zoom into center of image
      int x = getWidth() / 2;
      int y = getHeight() / 2;
      double xScaledClick = xStart + (xIncrement * x);
      double yScaledClick = yStart + (yIncrement * y);
      addMessage(&quot;Auto click location:  Screen(&quot; + x + &quot;,&quot; + y + &quot;) Scaled(&quot;
        + xScaledClick + &quot;,&quot; + yScaledClick + &quot;)&quot;);

      distance *= AUTO_ZOOM_FACTOR;
      xIncrement *= AUTO_ZOOM_FACTOR;
      yIncrement *= AUTO_ZOOM_FACTOR;

      addMessage(
        &quot;Auto zoom updated values: distance=&quot; + distance + &quot; xIncrement:&quot;
          + xIncrement + &quot; yIncrement:&quot; + yIncrement);

      LOG
        .debug(&quot;Auto zoom update plot with width:&quot; + getWidth() + &quot; height:&quot;
          + getHeight());

      // Calculate x,y start as 50% of new increment
      xStart = xScaledClick - (xIncrement * (getWidth() / 2));
      yStart = yScaledClick - (yIncrement * (getHeight() / 2));

      addMessage(&quot;Auto zoom another level: &quot; + autoZoomingCount);

      clearSurface();

      new Thread(this).start();
    } else {
      isAutoZoomingMode = false;
      addMessage(&quot;Auto zoom complete&quot;);
    }
  }

  private void plotFinished() {
    addMessage(&quot;plotFinished called at &quot; + new Date());
    if (isAutoZoomingMode) {
      runAutoZoom();
    }
  }

  @Override
  public void handleMenuClick(String menuItemName) {
    switch (menuItemName) {
      case &quot;Save Image to File&quot;:
        saveCurrentImage();
        break;
      case &quot;Exit&quot;:
        int exitOk = askYesNoQuestion(&quot;Verify Exit Request&quot;,
          &quot;Are you sure you want to exit the program?&quot;);
        if (exitOk == YES_OPTION) {
          closeWindow();
        }
        break;
    }
  }

  @Override
  public void handleKeyCode(int keyCode) {
    if (keyCode == KeyEvent.VK_F2) {
      saveCurrentImage();
    } else if (keyCode == KeyEvent.VK_F4) {
      pickLocation();
    } else if (keyCode == KeyEvent.VK_F6) {
      startAutoZoom();
    } else if (keyCode == KeyEvent.VK_F5) {
      addMessage(&quot;Zoom in/out from center&quot;);
      updatePlot(false, getWidth() / 2, getHeight() / 2);
    } else if (keyCode == KeyEvent.VK_LEFT) {
      shiftImage(0, -.2);
    } else if (keyCode == KeyEvent.VK_RIGHT) {
      shiftImage(0, .2);
    } else if (keyCode == KeyEvent.VK_UP) {
      shiftImage(.2, 0);
    } else if (keyCode == KeyEvent.VK_DOWN) {
      shiftImage(-.2, 0);
    }
  }

  @Override
  public void run() {
    addMessage(&quot;plot started at &quot; + new Date());
    plot();
    addMessage(&quot;plot returned at &quot; + new Date());

    if (LOG.isTraceEnabled()) {
      Integer[] keys =
        magnitudeCounts.keySet().toArray(new Integer[magnitudeCounts.size()]);
      Arrays.sort(keys);
      for (Integer magnitude : keys) {
        LOG.info(
          &quot;Magnitude:&quot; + magnitude + &quot; Count:&quot;
            + magnitudeCounts.get(magnitude));
      }
    }

    if (isAutoZoomingMode) {
      try {
        Thread.sleep(5000);
      } catch (Throwable t) {
        addMessage(&quot;Sleep interrupted during auto zoom operation&quot;);
      }

      plotFinished();
    }
  }
}
</pre>
<p>Wed Apr 06 16:33:05 EDT 2022</p>
</body>
</head>
